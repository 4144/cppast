// Copyright (C) 2017 Jonathan MÃ¼ller <jonathanmueller.dev@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level directory of this distribution.

#ifndef CPPAST_LIBCLANG_PARSER_HPP_INCLUDED
#define CPPAST_LIBCLANG_PARSER_HPP_INCLUDED

#include <stdexcept>

#include <cppast/parser.hpp>

namespace cppast
{
    class libclang_compile_config;

    namespace detail
    {
        struct libclang_compile_config_access
        {
            static const std::string& clang_binary(const libclang_compile_config& config);

            static int clang_version(const libclang_compile_config& config);

            static const std::vector<std::string>& flags(const libclang_compile_config& config);
        };
    } // namespace detail

    /// The exception thrown when a fatal parse error occurs.
    class libclang_error final : public std::runtime_error
    {
    public:
        /// \effects Creates it with a message.
        libclang_error(std::string msg) : std::runtime_error(std::move(msg))
        {
        }
    };

    /// A compilation database.
    ///
    /// This represents a `compile_commands.json` file,
    /// which stores all the commands needed to compile a set of files.
    /// It can be generated by CMake using the `CMAKE_EXPORT_COMPILE_COMMANDS` option.
    class libclang_compilation_database
    {
    public:
        /// \effects Creates it giving the directory where the `compile_commands.json` file is located.
        /// \throws `libclang_error` if the database could not be loaded or found.
        libclang_compilation_database(const std::string& build_directory);

        libclang_compilation_database(libclang_compilation_database&& other)
        : database_(other.database_)
        {
            other.database_ = nullptr;
        }

        ~libclang_compilation_database();

        libclang_compilation_database& operator=(libclang_compilation_database&& other)
        {
            libclang_compilation_database tmp(std::move(other));
            std::swap(tmp.database_, database_);
            return *this;
        }

    private:
        using database = void*;
        database database_;

        friend libclang_compile_config;
    };

    /// Compilation config for the [cppast::libclang_parser]().
    class libclang_compile_config final : public compile_config
    {
    public:
        /// Creates the default configuration.
        ///
        /// \effects It will set the clang binary determined by the build system,
        /// as well as the libclang system include directory determined by the build system.
        /// It will also define `__cppast__` with the value `"libclang"` as well as `__cppast_major__` and `__cppast_minor__`.
        libclang_compile_config();

        /// Creates the configuration stored in the database.
        ///
        /// \effects It will use the options found in the database for the specified file.
        /// This does not necessarily need to match the file that is going to be parsed,
        /// but it should.
        /// It will also add the default configuration options.
        /// \notes Header files are not included in the compilation database,
        /// you need to pass in the file name of the corresponding source file,
        /// if you want to parse one.
        /// \notes It will only consider options you could also set by the other functions.
        /// \notes The file key will include the specified directory in the JSON, if it is not a full path.
        libclang_compile_config(const libclang_compilation_database& database,
                                const std::string&                   file);

        /// \effects Sets the path to the location of the `clang++` binary and the version of that binary.
        /// \notes It will be used for preprocessing.
        void set_clang_binary(std::string binary, int major, int minor, int patch)
        {
            clang_binary_  = std::move(binary);
            clang_version_ = major * 10000 + minor * 100 + patch;
        }

    private:
        void do_set_flags(cpp_standard standard, compile_flags flags) override;

        void do_add_include_dir(std::string path) override;

        void do_add_macro_definition(std::string name, std::string definition) override;

        void do_remove_macro_definition(std::string name) override;

        const char* do_get_name() const noexcept override
        {
            return "libclang";
        }

        std::string clang_binary_;
        int         clang_version_;

        friend detail::libclang_compile_config_access;
    };

    /// A parser that uses libclang.
    class libclang_parser final : public parser
    {
    public:
        explicit libclang_parser(type_safe::object_ref<const diagnostic_logger> logger);
        ~libclang_parser() noexcept override;

    private:
        std::unique_ptr<cpp_file> do_parse(const cpp_entity_index& idx, std::string path,
                                           const compile_config& config) const override;

        struct impl;
        std::unique_ptr<impl> pimpl_;
    };
} // namespace cppast

#endif // CPPAST_LIBCLANG_PARSER_HPP_INCLUDED
